<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dual Grid: Isometric + Perlin</title>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/simplex-noise/2.4.0/simplex-noise.min.js"></script>
    
    <style>
        body {
            background-color: #1a1a1a;
            color: #eee;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
        }
        canvas {
            /* Pixelated rendering is crucial for tile art */
            image-rendering: pixelated; 
            box-shadow: 0 0 30px rgba(0,0,0,0.8);
            border: 1px solid #333;
            background-color: #0d0d0d;
        }
        .controls {
            margin-top: 15px;
            text-align: center;
            background: #2a2a2a;
            padding: 10px 20px;
            border-radius: 8px;
            z-index: 10;
        }
        button {
            background: #4da6ff;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            margin-left: 10px;
        }
        button:hover { background: #70baff; }
    </style>
</head>
<body>

    <canvas id="gridCanvas"></canvas>

    <div class="controls">
        <span style="color:#aaa">Map Generation:</span>
        <button onclick="window.regenerateMap()">New Random Map</button>
        <button onclick="window.toggleIso()">Toggle Isometric</button>
    </div>

    <script type="text/typescript">
        // --- CONFIGURATION ---
        const TILE_WIDTH = 64;   // Width of the tile in pixels
        const TILE_HEIGHT = 32;  // Height (usually half width for standard ISO)
        const GRID_SIZE = 30;    // Size of the data grid (30x30)

        // Globals provided by the script tag above
        declare const SimplexNoise: any;
        const simplex = new SimplexNoise();

        // --- TYPES ---
        enum TerrainType {
            Water = 0,
            Sand = 1,
            Dirt = 2,
            Grass = 3
        }

        // --- DUAL GRID SYSTEM ---
        class DualGridSystem {
            public width: number;
            public height: number;
            public cells: TerrainType[];
            public isIsometric: boolean = true; 

            constructor(width: number, height: number) {
                this.width = width;
                this.height = height;
                this.cells = new Array(width * height).fill(TerrainType.Water);
            }

            public getCell(x: number, y: number): TerrainType {
                if (x < 0 || x >= this.width || y < 0 || y >= this.height) return TerrainType.Water;
                return this.cells[y * this.width + x];
            }

            public setCell(x: number, y: number, type: TerrainType) {
                if (x >= 0 && x < this.width && y >= 0 && y < this.height) {
                    this.cells[y * this.width + x] = type;
                }
            }

            public generatePerlinMap() {
                // Scale affects the "zoom" of the noise. Lower = larger continents.
                const scale = 0.08; 
                const seed = Math.random() * 1000;

                for (let y = 0; y < this.height; y++) {
                    for (let x = 0; x < this.width; x++) {
                        // Get noise value between -1 and 1
                        const value = simplex.noise2D((x + seed) * scale, (y + seed) * scale);
                        
                        // Map noise to Terrain
                        let type = TerrainType.Water;
                        if (value > -0.2) type = TerrainType.Sand;
                        if (value > 0.0) type = TerrainType.Dirt;
                        if (value > 0.3) type = TerrainType.Grass;

                        this.setCell(x, y, type);
                    }
                }
            }

            public render(ctx: CanvasRenderingContext2D, canvasWidth: number, canvasHeight: number) {
                // Center the isometric map in the canvas
                const originX = canvasWidth / 2;
                const originY = 100; // Vertical padding

                for (let y = 0; y < this.height - 1; y++) {
                    for (let x = 0; x < this.width - 1; x++) {
                        
                        // 1. Get Neighbors (Dual Grid Logic)
                        const tl = this.getCell(x, y);
                        const tr = this.getCell(x + 1, y);
                        const bl = this.getCell(x, y + 1);
                        const br = this.getCell(x + 1, y + 1);

                        // 2. Calculate Position
                        let drawX, drawY;

                        if (this.isIsometric) {
                            // Isometric Projection Formula
                            // x * 0.5 * width  +  y * -0.5 * width
                            drawX = originX + (x - y) * (TILE_WIDTH / 2);
                            drawY = originY + (x + y) * (TILE_HEIGHT / 2);
                        } else {
                            // Standard Top-Down
                            drawX = x * 40; // 40px square size for top-down debug
                            drawY = y * 40;
                        }

                        // 3. Draw Tile (Procedural or Sprite)
                        this.drawTile(ctx, drawX, drawY, tl, tr, bl, br);
                    }
                }
            }

            private drawTile(
                ctx: CanvasRenderingContext2D, 
                x: number, y: number, 
                tl: TerrainType, tr: TerrainType, bl: TerrainType, br: TerrainType
            ) {
                // Debug Colors
                const colors = {
                    [TerrainType.Water]: '#225588',
                    [TerrainType.Sand]:  '#eebb44',
                    [TerrainType.Dirt]:  '#885533',
                    [TerrainType.Grass]: '#44aa44'
                };

                if (this.isIsometric) {
                    // Draw a Diamond Shape split into 4 logical quadrants
                    // In a real game, you would just draw: ctx.drawImage(atlas[id], x - offset, y - offset)
                    
                    ctx.save();
                    ctx.translate(x, y);
                    
                    // Draw the diamond shape path
                    // Top Quadrant (TL)
                    this.drawIsoQuad(ctx, colors[tl], 0, -TILE_HEIGHT/2);
                    // Right Quadrant (TR)
                    this.drawIsoQuad(ctx, colors[tr], TILE_WIDTH/2, 0);
                    // Bottom Quadrant (BR)
                    this.drawIsoQuad(ctx, colors[br], 0, TILE_HEIGHT/2);
                    // Left Quadrant (BL)
                    this.drawIsoQuad(ctx, colors[bl], -TILE_WIDTH/2, 0);

                    // Grid outline
                    ctx.beginPath();
                    ctx.moveTo(0, -TILE_HEIGHT);    // Top
                    ctx.lineTo(TILE_WIDTH, 0);      // Right
                    ctx.lineTo(0, TILE_HEIGHT);     // Bottom
                    ctx.lineTo(-TILE_WIDTH, 0);     // Left
                    ctx.closePath();
                    ctx.strokeStyle = "rgba(0,0,0,0.1)";
                    ctx.stroke();
                    
                    ctx.restore();

                } else {
                    // Standard Square Debug Drawing
                    const size = 40;
                    const half = size / 2;
                    
                    ctx.fillStyle = colors[tl]; ctx.fillRect(x, y, half, half);
                    ctx.fillStyle = colors[tr]; ctx.fillRect(x + half, y, half, half);
                    ctx.fillStyle = colors[bl]; ctx.fillRect(x, y + half, half, half);
                    ctx.fillStyle = colors[br]; ctx.fillRect(x + half, y + half, half, half);
                    ctx.strokeStyle = "rgba(0,0,0,0.2)";
                    ctx.strokeRect(x, y, size, size);
                }
            }

            // Helper to draw a small diamond quadrant for procedural debug
            private drawIsoQuad(ctx: CanvasRenderingContext2D, color: string, offsetX: number, offsetY: number) {
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.moveTo(0, 0); // Center of tile
                
                // This math simply fills 1/4th of the diamond based on which corner we are drawing
                // It's purely for debug visualization purposes.
                if(offsetY < 0) { // Top
                     ctx.lineTo(TILE_WIDTH/2, -TILE_HEIGHT/2); 
                     ctx.lineTo(0, -TILE_HEIGHT); 
                     ctx.lineTo(-TILE_WIDTH/2, -TILE_HEIGHT/2);
                } else if(offsetX > 0) { // Right
                     ctx.lineTo(TILE_WIDTH/2, -TILE_HEIGHT/2); 
                     ctx.lineTo(TILE_WIDTH, 0); 
                     ctx.lineTo(TILE_WIDTH/2, TILE_HEIGHT/2);
                } else if(offsetY > 0) { // Bottom
                     ctx.lineTo(TILE_WIDTH/2, TILE_HEIGHT/2); 
                     ctx.lineTo(0, TILE_HEIGHT); 
                     ctx.lineTo(-TILE_WIDTH/2, TILE_HEIGHT/2);
                } else { // Left
                     ctx.lineTo(-TILE_WIDTH/2, -TILE_HEIGHT/2); 
                     ctx.lineTo(-TILE_WIDTH, 0); 
                     ctx.lineTo(-TILE_WIDTH/2, TILE_HEIGHT/2);
                }
                ctx.fill();
            }
        }

        // --- APP SETUP ---

        const canvas = document.getElementById('gridCanvas') as HTMLCanvasElement;
        const ctx = canvas.getContext('2d')!;

        // Fullscreen Canvas
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        const grid = new DualGridSystem(GRID_SIZE, GRID_SIZE);
        grid.generatePerlinMap();

        // --- LOOP ---
        function loop() {
            // Background
            ctx.fillStyle = "#0d0d0d";
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            grid.render(ctx, canvas.width, canvas.height);
            requestAnimationFrame(loop);
        }
        loop();

        // --- EXPOSED FUNCTIONS FOR UI ---
        (window as any).regenerateMap = () => {
            grid.generatePerlinMap();
        };

        (window as any).toggleIso = () => {
            grid.isIsometric = !grid.isIsometric;
            // Center camera reset logic could go here
        };

        // Handle resize
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });

    </script>
</body>
</html>